#!/usr/bin/perl
#
# $Cambridge$

use warnings;
use strict;

use Getopt::Std;

sub fail { die  "nsdiff: @_\n"; }
sub wail { warn "nsdiff: @_\n"; }

# for named-compilezone
$ENV{PATH} .= ":/sbin:/usr/sbin:/usr/local/sbin";

sub usage {
    print STDERR <<EOF;
usage: nsdiff [options] <zone> [old] <new>
  Generate an `nsupdate` script that changes a zone from the
  "old" version into the "new" version, ignoring DNSSEC records.
  If the "old" file is omitted, `nsdiff` will AXFR the zone.
options:
  -S date|serial|unix|num  SOA serial update mode or set number
  -v [q][r]                verbose query and/or reply
  -b address               dig query source address
  -k keyfile               dig query TSIG key
  -y [hmac:]name:key       dig query TSIG key
EOF
    exit 1;
}
my %opt;
usage unless getopts 'qv:S:b:k:y:', \%opt;
usage unless @ARGV == 2 || @ARGV == 3;

my @digopts;
for my $o (qw{ b k y }) {
    push @digopts, "-$o $opt{$o}" if exists $opt{$o};
}
wail "ignoring dig options when loading old zone from file"
    if @digopts && @ARGV != 2;

usage if $opt{v} && $opt{v} !~ m{^[qr]*$};
my $verbosity = $opt{v} || 'r';

my $soamin = 0;
my %soamin =
(   serial => sub { return $soamin; },
    unix => sub { return time; },
    date => sub {
	my ($sec,$min,$hour,$mday,$mon,$year) = gmtime;
	return sprintf "%04d%02d%02d%02d", 1900+$year,1+$mon,$mday,0;
    }
);
my $soamode = $opt{S} || 'serial';
$soamin = $soamode, $soamode = 'serial' if $soamode =~ m{^[0-9]+$};
usage unless exists $soamin{$soamode};

# These variables are unlikely to need changing.

my $label = qr{[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?};
my $ulabels = qr{(?:_$label[.])+};
my $labels = qr{$label(?:[.]$label)*[.]?};
my $wlabels = qr{(?:[*][.]|$ulabels)?$labels};
my $fqdnre = qr{^$labels$};
my $soare = qr{^($labels) (\d+) (IN SOA $labels $labels) (\d+) (\d+ \d+ \d+ \d+\n)$};

my $compilezone = 'named-compilezone -i local -k warn -n warn -o -';

# normalize whitespace and remove DNSSEC records
sub cleanzone {
    my @zone = grep {
	s{\s+}{ }g;
	s{\s*$}{\n};
	not m{^$wlabels \d+ IN (NSEC|NSEC3|NSEC3PARAM|RRSIG|DNSKEY|TYPE65534) };
    } @_;
    my $soa = shift @zone;
    fail "missing SOA record" unless defined $soa and $soa =~ $soare;
    # put zone into keys of a hash
    my %zone; @zone{@zone} = ();
    return $soa, \%zone;
}

sub axfrzone {
    my $zone = shift;
    my @soa = split ' ', qx{dig @digopts +short soa $zone};
    my $master = $soa[0];
    fail "could not get SOA record for $zone"
	unless defined $master and $master =~ $fqdnre;
    wail "loading zone $zone from AXFR";
    return cleanzone qx{dig @digopts axfr $zone \@$master | $compilezone $zone /dev/stdin};
}

sub loadzone {
    my ($zone,$file) = @_;
    wail "loading zone $zone from file $file";
    return cleanzone qx{$compilezone -j $zone '$file'};
}

my $zone = shift;
fail "not a domain name: $zone" unless $zone =~ $fqdnre;

my ($soa,$old) = (@ARGV == 1)
                  ? axfrzone $zone
                  : loadzone $zone, shift;
my ($newsoa,$new) = loadzone $zone, shift;

my $size = 0;

sub doit {
    my $len = shift;
    # Do not do a no-op.
    return if $size == -$len;
    print "show\n" if $verbosity =~ m{q};
    print "send\n";
    print "answer\n" if $verbosity =~ m{r};
}

sub emit {
    my $cmd = "@_";
    $size -= length $cmd;
    if ($size <= 0) {
	doit length $cmd;
	# Keep within 64 KiB DNS packet limit and allow for slop.
	$size = 50000;
	# Use SOA serial for race protection.
	$soa =~ $soare;
	print "prereq yxrrset $1 $3 $4 $5";
	my $min = $soamin{$soamode}();
	my $serial = $4 >= $min ? $4 + 1 : $min;
	$newsoa =~ $soare;
	print "update add ", $soa = "$1 $2 $3 $serial $5";
    }
    print $cmd;
}

# Do deletions and additions for each owner name in that order.
# This ensures TTL adjustments and CNAME/other replacements are
# handled correctly.

sub del_add {
    my ($owner,$del,$add) = @_;
    emit "update delete", $owner, $_ for @$del;
    emit "update add",    $owner, $_ for @$add;
}

my (%del,%add);
for my $rr (keys %$old) {
    delete $old->{$rr};
    if (exists $new->{$rr}) {
	# Filter out unchanged records.
	delete $new->{$rr};
    } else {
	# Remember deletions.
	my ($owner,$ttl,$data) = split ' ', $rr, 3;
	push @{$del{$owner}}, $data;
    }
}
for my $rr (keys %$new) {
    delete $new->{$rr};
    # Remember additions.
    my ($owner,$data) = split ' ', $rr, 2;
    push @{$add{$owner}}, $data;
}

# Output changes.

for my $owner (keys %del) {
    del_add $owner, $del{$owner}, $add{$owner};
    delete $add{$owner} if exists $add{$owner};
    delete $del{$owner};
}
for my $owner (keys %add) {
    del_add $owner, undef, $add{$owner};
    delete $add{$owner};
}

doit 0;

exit;

__END__

=head1 NAME

nsdiff - create "nsupdate" script from DNS zone file diffrences

=head1 SYNOPSIS

nsdiff [B<-b> I<address>] [B<-k> I<keyfile>] [B<-y> [I<hmac>:]I<name>:I<key>]
       [B<-S> B<date>|B<serial>|B<unix>|I<num>] <I<zone>> [I<old>] <I<new>>

=head1 DESCRIPTION

The C<nsdiff> program examines the F<old> and F<new> versions of a DNS
zone, and outputs the differences as a script for use by BIND's
C<nsupdate> program. It ignores DNSSEC-related differences, assuming
that the name server has sole control over zone keys and signatures.

The input files are typically in standard DNS master file format. They
are passed through BIND's C<named-compilezone> program to convert them
to canonical form, so they may also be in BIND's "raw" format and may
have F<.jnl> update journals.

If the F<old> file is not specified, C<nsdiff> will use C<dig> to
transfer the zone from its master server as identified in the zone's
SOA MNAME field.

=head1 OPTIONS

=over

=item B<-S> B<date>|B<serial>|B<unix>|I<num>

Choose the SOA serial number update mode: the default I<serial> just
increments the serial number; I<date> uses a number of the form
YYYYMMDDnn and allows for up to 100 updates per day; I<unix> uses the
UNIX "seconds since the epoch" value. You can also specify an explicit
serial number value. In all cases, if the current serial number is
larger than the target value it is just incremented. Serial number
wrap-around is not supported.

=item B<-v> [q][r]

Control verbosity.
The B<q> flag causes queries to be printed.
The B<r> flag causes responses to be printed.
To make C<nsdiff> quiet, use B<-v ''>.

=back

The following options are passed to C<dig> to modify its SOA and AXFR
queries:

=over

=item B<-b> I<address>

AXFR query source address

=item B<-k> I<keyfile>

TSIG key file for AXFR query

=item B<-y> [I<hmac>:]I<name>:I<key>

Literal TSIG key for AXFR query

=back

=head1 DIAGNOSTICS

=over

=item C<could not get SOA record for I<zone>>

Error emitted when C<dig> fails to retreive the zone's SOA.

=item C<missing SOA record>

Error emitted when the output of C<named-compilezone> is incomplete,
usually because the input file is erroneous.

=item C<not a domain name: I<zone>>

Error emitted if the first argument's syntax is wrong.

=item C<usage: ...>

Error emitted if the command line arguments are wrong.

=item C<ignoring dig options when loading old zone from file>

Warning emitted when the command line includes options for C<dig>
as well as an old zone source file.

=item C<loading zone I<zone> from AXFR>

=item C<loading zone I<zone> from file I<file>>

Normal progress messages emitted before C<nsdiff> invokes
C<named-compilezone>, to explain the latter's diagnostics.

=back

=head1 EXAMPLES

It is easiest to deploy DNSSEC if you allow C<named> to manage zone keys
and signatures automatically, and feed in changes to zones using DNS
update requests. However this is very different from the traditional way
of manually maintaining zones in standard master file format. The
C<nsdiff> program bridges the gap between the two operational styles.

To support this workflow you need BIND-9.7 or newer. You will continue
maintaining your zone master file C<$sourcefile> as before, but it is no
longer the same as the C<$workingfile> used by C<named>. After you make
a change, instead of using C<rndc reload $zone>, run C<nsdiff $zone
$sourcefile | nsupdate -l>.

Configure your zone as follows, to support DNSSEC and local dynamic updates:

  zone $zone {
    type master;
    file "$workingfile";
    auto-dnssec maintain;
    update-policy local;
  };

To create DNSSEC keys for your zone, change to named's working directory
and run these commands:

  dnssec-keygen -f KSK $zone
  dnssec-keygen $zone

=head1 CAVEATS

Note that C<nsdiff> does not maintain the transactional semantics of
native DNS update requests when the diff is large - it applies the changes
in multiple update requests. This gives you a small risk of clients not
seeing a change applied atomically when that matters (e.g. altering an MX
and creating the new target in the same transaction). You may be able to
avoid this if you have good control over what gets changed when.

Also, if something else is making changes to the zone at the time you run
C<nsdiff> and C<nsupdate>, then some or all of the changes may be rejected
by the server. This may happen even in simple setups if C<named> happens
to be re-signing the zone at the time you make an update. The SOA serial
number prerequisite checks are supposed to catch this problem, but they
are a bit weak when the changes are split into multiple transactions. But
if this happens it should be safe to just re-run C<nsdiff | nsupdate>
(though the warning about delicate dependencies applies even more
strongly).

The current operational trade-offs in C<nsdiff> are not necessarily the
right ones. For instance you might prefer to abort rather than split the
changes into multiple transactions, and/or you might need to use another
RR for consistency checks instead of or as well as the SOA serial number.
Feedback is welcome.

=head1 AUTHOR

=over

=item Written by Tony Finch <fanf2@cam.ac.uk> <dot@dotat.at>

=item at the University of Cambridge Computing Service.

=item You may do anything with this. It has no warranty.

=item L<http://creativecommons.org/publicdomain/zero/1.0/>

=back

=head1 ACKNOWLEDGMENTS

Thanks to Terry Burton at the University of Leicester and Piete Brooks
at the University of Cambridge Computer Laboratory for providing
useful feedback.

=head1 SEE ALSO

dig(1), nsupdate(1), named(8), named-compilezone(8)

=cut
