#!/usr/bin/perl
#
# $Cambridge$

use warnings;
use strict;

my $label = qr{[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?};
my $labels = qr{$label(?:[.]$label)*[.]?};
my $domain = qr{^$labels$};
my $soare = qr{^($labels) (\d+) (IN SOA $labels $labels) (\d+) (\d+ \d+ \d+ \d+\n)$};
my $cmpre = qr{^($labels) \d+ IN ([A-Z]+) .*\n$};

my $compilezone = 'named-compilezone -i local -k warn -n warn -o -';

sub wail { warn "nsdiff: @_\n"; }
sub fail { die  "nsdiff: @_\n"; }

# normalize whitespace and remove DNSSEC records
sub cleanzone {
    my @zone = grep {
	s{\s+}{ }g;
	s{\s*$}{\n};
	not m{^$labels \d+ IN (NSEC|NSEC3|NSEC3PARAM|RRSIG|DNSKEY|TYPE65534) };
    } @_;
    my $soa = shift @zone;
    fail "missing SOA record" unless defined $soa and $soa =~ $soare;
    return $soa, sort @zone;
}

sub axfrzone {
    my $zone = shift;
    my @soa = split ' ', qx{dig +short soa $zone};
    my $master = $soa[0];
    fail "could not get SOA record for $zone"
	unless defined $master and $master =~ $domain;
    wail "loading zone $zone from AXFR";
    return cleanzone qx{dig axfr $zone \@$master | $compilezone $zone /dev/stdin};
}

sub loadzone {
    my ($zone,$file) = @_;
    wail "loading zone $zone from file $file";
    return cleanzone qx{$compilezone -j $zone '$file'};
}

sub usage {
    print STDERR <<EOF;
usage: nsdiff <zone> [old] <new>
Generate an `nsupdate` script that changes a zone from the "old" version
into the "new" version. DNSSEC-related differences are ignored.
The input files can be `named` working zone files with journals. If the
"old" file is not specified, `nsdiff` will AXFR the zone from the master
server identified in the SOA MNAME field.
EOF
    exit 1;
}
usage if @ARGV != 2 && @ARGV != 3;

my $zone = shift;
fail "not a domain name: $zone" unless $zone =~ $domain;

my ($old,@old) = (@ARGV == 1)
                  ? axfrzone $zone
                  : loadzone $zone, shift;
my ($new,@new) = loadzone $zone, shift;

my ($soa,$newsoa) = ($old,$new);

sub doit { print "send\nanswer\n"; }

my $size = 0;
sub emit {
    my $cmd = "@_";
    $size += length $cmd;
    if ($size > 50000) {
	$size = 0;
	doit;
	&bumpsoa;
    }
    print $cmd;
}

sub del {
    $old =~ m{^($labels) \d+ (.*)$}s;
    emit "update delete", $1, $2;
    $old = shift @old;
}
sub add {
    emit "update add", $new;
    $new = shift @new;
}
sub shift2 {
    $old = shift @old;
    $new = shift @new;
}

sub bumpsoa {
    $soa =~ $soare;
    my $serial = $4 + 1;
    emit "prereq yxrrset", $1, $3, $4, $5;
    $newsoa =~ $soare;
    emit "update add", $soa = "$1 $2 $3 $serial $5";
}

sub rrcmp {
    my ($newname,$newtype) = ($new =~ $cmpre);
    my ($oldname,$oldtype) = ($old =~ $cmpre);
    # If name and type are equal, always delete old RRs before adding
    # new ones. This ensures TTL adjustments are handled correctly.
    return ($newname cmp $oldname or $newtype cmp $oldtype or $new ne $old);
}

bumpsoa;
shift2;
my @act = (\&shift2, \&del, \&add);
$act[rrcmp]()
    while defined $old and defined $new;
del while defined $old;
add while defined $new;
doit;

exit;
